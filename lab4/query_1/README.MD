# Анализ запроса №1

## Запрос на языке SQL

```sql
select Н_ОЦЕНКИ.ПРИМЕЧАНИЕ, Н_ВЕДОМОСТИ.ДАТА
from Н_ВЕДОМОСТИ
left join Н_ОЦЕНКИ on Н_ВЕДОМОСТИ.ОЦЕНКА = Н_ОЦЕНКИ.КОД
where (
    Н_ОЦЕНКИ.ПРИМЕЧАНИЕ > 'неявка'
    and
    Н_ВЕДОМОСТИ.ИД = 1457443
    and
    Н_ВЕДОМОСТИ.ИД > 39921
);
```

## Индексы

Для данного запроса полезными могут оказаться:

1) Hash (Хэш)

hash-индекс лучше использовать в местах применения знака `=` (в том числе, JOIN'ов). При этом учтём то, что индексы неэффективны, если в таблице мало строк. Индекс бесполезен, если строки могут содержать одинаковые значения. Таким образом hash-индекс логично создать для следующих отношений:

- Н_ВЕДОМОСТИ(ОЦЕНКА) -- для ускорения `JOIN`'а (хотя, из-за большого количества выборки, индекс может быть не так эффективен, как ожидается)
- Н_ВЕДОМОСТИ(ИД) -- для ускорения `WHERE =`

2) B-tree (бинарное дерево)

b-tree-индекс можно использовать в тех же местах, где используется hash-индекс, однако стоит учитывать сложность поиска: O(1) для hash и O(logN) для b-tree. Помимо указанного, данный индекс может быть полезен при выборке WHERE с использованием знака неравенства, а значит:

- Н_ОЦЕНКИ(ПРИМЕЧАНИЕ) -- для ускорения `WHERE >`
- Н_ВЕДОМОСТИ(ИД) -- для ускорения `WHERE >`

3) GiST (Обобщенное дерево поиска)

По моему мнению, избыточно для предлагаемых данных, поскольку GiST индексы полезны в тех случаях, когда мы управляем сложными структурами данных (например, геоданные, текстовые документы, изображения и проч.).

4) SP-GiST (Обобщенное дерево поиска по разделенному пространству)

Данный индекс, как мне кажется, тоже будет излишним, поскольку мои данные не представляют из себя структуры с возможным раздедлением пространства.

5) GIN (Обобщенный инвертированный индекс)

В представленном запросе не происходит полнотекстового поиска (происходит поиск по полной строке), следовательно, данный индекс так же будет бесполезен.

6) BRIN (Индекс зон блоков)

brin-индекс может быть полезен в контексте исключительных данных. Так, более-менее натуральная корреляция с физическим расположением записей может наблюдаться в колонках-идентификаторах (потому что чем позже был добавлен пользователь, тем больше у него индекс), хотя гарантии на это нет. С учетом сказанного, индекс может быть использован:

- Н_ВЕДОМОСТИ(ИД) -- для ускорения `WHERE >` и `WHERE =`

Итого, наилучшим сочетанием индексов я считаю:

> b-tree для Н_ВЕДОМОСТИ(ИД)
>
> и
>
> hash для Н_ВЕДОМОСТИ(ОЦЕНКА)

Это позволит ускорить операцию WHERE и соединение JOIN для таблиц.

## Планы выполнения запроса

### До добавления индексов

### После добавления индексов

## Вывод команды `EXPLAIN ANALYZE`

![explain_analyze_q1](/lab4/query_1/img/explain_analyze_q1.png)
