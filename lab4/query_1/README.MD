# Анализ запроса №1

## Запрос на языке SQL

```sql
select Н_ОЦЕНКИ.ПРИМЕЧАНИЕ, Н_ВЕДОМОСТИ.ДАТА
from Н_ВЕДОМОСТИ
left join Н_ОЦЕНКИ on Н_ВЕДОМОСТИ.ОЦЕНКА = Н_ОЦЕНКИ.КОД
where (
    Н_ОЦЕНКИ.ПРИМЕЧАНИЕ > 'неявка'
    and
    Н_ВЕДОМОСТИ.ИД = 1457443
    and
    Н_ВЕДОМОСТИ.ИД > 39921
);
```

## Индексы

Для данного запроса полезными могут оказаться:

1) Hash (Хэш)

hash-индекс лучше использовать в местах применения знака `=` (в том числе, JOIN'ов). При этом учтём то, что индексы неэффективны, если в таблице мало строк. Индекс бесполезен, если строки могут содержать одинаковые значения. Таким образом hash-индекс логично создать для следующих отношений:

- Н_ВЕДОМОСТИ(ОЦЕНКА) -- для ускорения `JOIN`'а
- Н_ВЕДОМОСТИ(ИД) -- для ускорения `WHERE =` (однако, как упоминалось раньше, он будет полезен только в этом выражении: поиск по WHERE)

2) B-tree (бинарное дерево)

b-tree-индекс можно использовать в тех же местах, где используется hash-индекс, однако стоит учитывать сложность поиска: O(1) для hash и O(logN) для b-tree. Помимо указанного, данный индекс может быть полезен при выборке WHERE с использованием знака неравенства, а значит:

- Н_ОЦЕНКИ(ПРИМЕЧАНИЕ) -- для ускорения `WHERE >`
- Н_ВЕДОМОСТИ(ИД) -- для ускорения `WHERE >` и `WHERE =`

3) GiST (Обобщенное дерево поиска)

По моему мнению, избыточно для предлагаемых данных, поскольку GiST индексы полезны в тех случаях, когда мы управляем сложными структурами данных (например, геоданные, текстовые документы, изображения и проч.).

4) SP-GiST (Обобщенное дерево поиска по разделенному пространству)

Данный индекс, как мне кажется, тоже будет излишним, поскольку мои данные не представляют из себя структуры с возможным раздедлением пространства.

5) GIN (Обобщенный инвертированный индекс)

В представленном запросе не происходит полнотекстового поиска (происходит поиск по полной строке), следовательно, данный индекс так же будет бесполезен.

6) BRIN (Индекс зон блоков)

brin-индекс может быть полезен в контексте исключительных данных. Так, более-менее натуральная корреляция с физическим расположением записей может наблюдаться в колонках-идентификаторах (потому что чем позже был добавлен пользователь, тем больше у него индекс), хотя гарантии на это нет. С учетом сказанного, индекс может быть использован:

- Н_ВЕДОМОСТИ(ИД) -- для ускорения `WHERE >` и `WHERE =`

Итого, наилучшим сочетанием индексов в рамках данного запроса я считаю:

> b-tree для Н_ВЕДОМОСТИ(ИД)
>
> b-tree для Н_ОЦЕНКИ(ПРИМЕЧАНИЕ)
>
> hash для Н_ВЕДОМОСТИ(ОЦЕНКА)

Это позволит ускорить операцию WHERE и соединение JOIN для таблиц.

## Планы выполнения запроса

### До добавления индексов

1) Первый возможный план - "в лоб". Подразумевает последовательные соединение, выборку и проекцию:

![plan1](/lab4/query_1/img/q1_plan1.svg)

2) Второй план заключается в ускорении первого посредством вынесения выборки до соединения. Таким образрм, соединение будет проходить быстрее:

![plan2](/lab4/query_1/img/q1_plan2.svg)

3) Третий же план предполагает раннюю проекцию так же для усокрения соединения:

![plan3](/lab4/query_1/img/q1_plan3.svg)

4) Ну и четвертый план. Я назвал его: "План минимального множества", когда каждая операция на вход принимает минимально возможное количество столбцов.

![plan4](/lab4/query_1/img/q1_plan4.svg)

### После добавления индексов

Для первого плана логично использовать свой набор индексов, потому что:

Из-за конвеерной обработки, нужда в индексах для Н_ВЕДОМОСТИ(ИД) и Н_ОЦЕНКИ(ПРИМЕЧАНИЯ) одновеременно отпадает

В случае же использования 2 и 3 планов, все индексы релевантны.

## Вывод команды `EXPLAIN ANALYZE`

Команда демонстрирует то, что планировщиком был выбран план №1

![explain_analyze_q1](/lab4/query_1/img/explain_analyze_q1.png)
